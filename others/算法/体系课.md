## C2

- 找到一个数

```java
public static void findTarget(int[] sortedArr, int target){
    if(sortedArr == null or sortedArr.length == 0){
        return false;
    }
    int left = 0;
    int right = sortedArr.length - 1;
    int mid = 0;
    while(left < right){
        // 防止溢出
        mid = left + ((right - left) >> 1);
        if(sortedArr[mid] == target){
            return true;
        }else if (sortedArr[mid] > target){
            right = mid - 1;
        }else{
            left = mid + 1;
        }
    }
    // 可能没有进入while中 需要判断
    return sortedArr[left] == target;
}
```

- 满足大于等于value的最左位置

```java
public static void findTarget(int[] sortedArr, int target){
    if(sortedArr == null or sortedArr.length == 0){
        return -1;
    }
    int left = 0;
    int right = sortedArr.length - 1;
    // 创建一个变量来更新位置
    int index = -1;
    while(left <= right){
        // 防止溢出
        int mid = left + ((right - left) >> 1);
        if(sortedArr[mid] >= target){
            index = mid;
            right = mid - 1;
        }else{
            left = mid + 1;
        }
    }
    // 可能没有进入while中 需要判断
    return index;
}
```

- 局部最小值

```java
public static int getLessIndex(int[] arr){
    // 输入数据判断
    if(arr == null || arr.length == 0){
        return -1;
    }
    // 先判断两端  验证0位置
    if(arr.length == 1 || arr[0] < arr[1]){
        return 0;
    }
    // 验证最后一位置
    if(arr[arr.length -1] < arr[arr.length -2]){
        return arr.length - 1;
    }
    // 定义左右
    int left = 0;
    int right = arr.length - 1;
    int mid = 0;
    while(left < right){
        mid = left + ((right - left) >> 1);
        // mid 比左大 左侧找
        if(arr[mid] > arr[mid - 1]){
            right = mid - 1;
        // mid比右侧大 右侧找
        }else if (arr[mid] > arr[mid + 1]){
            left = mid + 1;
        }else{
            return mid;
        }
    }
    // 如果只有一个数 需要返回left
    return left;
}
```

## C3 异或

```java
// 题目四
public static void printOddTimeNum(int[] arr){
    int eor = 0;
    for(int i = 0; i < arr.length; i++){
        eor ^= arr[i];
    }
    // 提取rightone
    int rightOne = eor&(-eor);
    int onlyOne = 0;
    for(int j = 0; j < arr.length; j++){
        if((arr[i] & rightOne) != 0){
            onlyOne ^= arr[i];
        }
    }
}


// 题目五
// 一个数出现k次，其他出现m次 k< m

public static int OnlyKTime(int[] arr, int k, int m){
    int[] t = new int[32];
    for(int num : arr){
        for(int i = 0; i < 32; i++){
            // 二进制位为1时需++
            if(((num >> i) & 1) != 0){
                t[i]++;
            }
        }
    }
    int ans = 0；
    for(int i = 0; i < 32; i++){
        if(t[i] % m != 0){ // 表示在i位上有1
            ans |= (1 << i); // 把1或进去
        }
    }
    return ans;
}
// 对数器
```

## C4

```java
// 单链表结构
public class Node{
    public int value;
    public Node next;
    public Node(int data){
        value = data;
    }
}

// 双链表
public class DoubleNode{
    public int value;
    public DoubleNode last;
    public DoubleNode next;
    public DoubleNode(int data){
        value = data;
    }
}
```

- 单链表反转

```java
public static Node reverseLinkedList(Node head){
    Node next = null;
    Node pre = null;
    while(head != null){
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
```

- 删除指定节点

```java
public static Node removeValue(Node head, int num){
    // 第一个不需要删除的位置  作为头节点
    while(head != null){
        if(head.value != num){
            break;
        }
        head = head.next;
    }
    // head为null  或者head 不为null
    Node pre = head;
    Node cur = head;
    // 是value则跳过，不是则pre指向该节点
    while(cur != null){
        if(cur.value == num){
            pre.next = cur.next;
        }else{
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}, 
```



## C5

- 归并排序

```java
// 递归版本归并排序

public static void mergeSort1(int[] arr){
    if(arr == null || arr.length == 0){
        return;
    }
    process(arr, 0, arr.length - 1);
}

public static void process(int[] arr, int left, int right){
    if(left == right){
        return;
    }
    // 拆分中点
    int mid = left + ((right - left) >> 1);
    // 先左右排序
    process(arr, left, mid);
    process(arr, mid+1, right);
    // 将排序的数据合并
    merge(arr, left, mid, right);
}

public static void merge(int[] arr, int left, int right, int mid, int right){
    // 创建辅助数组,先保存排好序的数据
    int[] help = new int[right - left + 1];
    // i用来标示辅助数组的指针位置
    int i = 0;
    // 创建p1和p2两个指针
    int p1 = left;
    int p2 = mid + 1;
    while(p1 <= mid && p2 <= right){
        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
    }
    // 一边走完之后剩余， 后面两个while只会发生一个
    while(p1 <= mid){
        help[i++] = arr[p1++];
    }
    while(p2 <= right){
        help[i++] = arr[p2++];
    }
    // 将原数组替换，靠谱至原数组
    for(int i = 0; i < help.length; i++){
        arr[left + i] = help[i];
    }
}



// 迭代版 递归  用步长扩大的方法  步长次数 nlogn
public static void mergeSort2(int[] arr){
    if(arr == null || arr.length == 0){
        return;
    }
    int N = arr.length;
    // 步长
    int mergeSize = 1;
    // 步长需小于N
    while(mergeSize < N){
        // 当前左组第一个位置
        int left = 0;
        while(left < N){
            // 左组的右边界，如果在最后一个可能不够
            int M = left + mergeSize - 1;
            if(M >= N){
                break;
            }
            int right = Math.min(M + mergeSize, N - 1);
            merge(arr, left, M, right);
            left = R + 1;
        }
        // 防止溢出
        if(mergeSize > N / 2){
            break;
        }
        // 步长乘2
        mergeSize <<= 1;
    }
}
```



- 小和问题，一个数组，左边比它小的累加

转换为右边有几个数比它大获得，只与右边的数比较



```java
public static int smallSum(int[] arr){
    if(arr == null || arr.length < 2){
        return 0;
    }
    process(arr, 0, arr.length - 1);
}

public static int process(int[] arr, int left, int right){
    if(left == right){
        return 0;
    }
    int mid = left + ((right - left) >> 1);
    return 
        process(arr, left, mid)
        +
        process(arr, mid + 1, right)
        +
        merge(arr, left, mid, right);
}


public static void merge(int[] arr, int left, int right, int mid, int right){
    // 创建辅助数组,先保存排好序的数据
    int[] help = new int[right - left + 1];
    // i用来标示辅助数组的指针位置
    int i = 0;
    // 创建p1和p2两个指针
    int p1 = left;
    int p2 = mid + 1;
    // 用于收集小和结果
    int res = 0;
    while(p1 <= mid && p2 <= right){
        res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
    }
    // 一边走完之后剩余， 后面两个while只会发生一个
    while(p1 <= mid){
        help[i++] = arr[p1++];
    }
    while(p2 <= right){
        help[i++] = arr[p2++];
    }
    // 将原数组替换，靠谱至原数组
    for(int i = 0; i < help.length; i++){
        arr[left + i] = help[i];
    }
    return res;
}
```

- 逆序对个数

- num 大于 右边数*2   右边数的个数累加

mergeSort 把比较变为有序 --> 获取算法原型

## C6

```java
// 求前缀和
public static int countRangeSum(int[] nums, int lower, int upper){
    if(nums == null || nums.length == 0){
        return 0;
    }
    int[] sum = new int[nums.length];
    sum[0] = nums[0];
    for(int i = 1; i < nums.length; i++){
        sum[i] = nums[i - 1] + nums[i];
    }
    return count(sum, 0, nums.length - 1, lower, upper);
}

// 计算原始数组中有多少个子数组在lower和upper中
public static int count(int[] sum, int L, int R, int lower, int upper){
    if(L == R){
        if(sum[L] >= lower && sum[L] <= upper){
            return 1;
        }else{
            return 0;
        }
    }
    // 范围上不止一个位置
    int mid = L + ((R - L) >> 1);
    int leftPart = count(sum, L, mid, lower, upper);
    int rightPart = count(sum, mid+1, R, lower, upper);
    int merge = merge(sum, L, mid, R, lower, upper);
    return leftPart + rightPart + merge;
    
}

public static int merge(int[] sum, int L, int mid, int R, int lower, int upper){
    // 窗口不回退
    int ans = 0;
    int windowL = L;
    int windowR = L;
    for(int i = mid + 1; i <= R; i++){
        int min = arr[i] - upper;
        int max = arr[i] - lower;
        // 滑动左右
        while(windowR <= mid && sum[windowR] <= max){
            windowR++;
        }
        while(windowL <= mid && sum[windowL] < min){
            windowL++;
        }
        ans += Math.max(0, windowR - windowL);
    }
    
    
    
}
```


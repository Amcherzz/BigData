## C2

- 找到一个数

```java
public static void findTarget(int[] sortedArr, int target){
    if(sortedArr == null or sortedArr.length == 0){
        return false;
    }
    int left = 0;
    int right = sortedArr.length - 1;
    int mid = 0;
    while(left < right){
        // 防止溢出
        mid = left + ((right - left) >> 1);
        if(sortedArr[mid] == target){
            return true;
        }else if (sortedArr[mid] > target){
            right = mid - 1;
        }else{
            left = mid + 1;
        }
    }
    // 可能没有进入while中 需要判断
    return sortedArr[left] == target;
}
```

- 满足大于等于value的最左位置

```java
public static void findTarget(int[] sortedArr, int target){
    if(sortedArr == null or sortedArr.length == 0){
        return -1;
    }
    int left = 0;
    int right = sortedArr.length - 1;
    // 创建一个变量来更新位置
    int index = -1;
    while(left <= right){
        // 防止溢出
        int mid = left + ((right - left) >> 1);
        if(sortedArr[mid] >= target){
            index = mid;
            right = mid - 1;
        }else{
            left = mid + 1;
        }
    }
    // 可能没有进入while中 需要判断
    return index;
}
```

- 局部最小值

```java
public static int getLessIndex(int[] arr){
    // 输入数据判断
    if(arr == null || arr.length == 0){
        return -1;
    }
    // 先判断两端  验证0位置
    if(arr.length == 1 || arr[0] < arr[1]){
        return 0;
    }
    // 验证最后一位置
    if(arr[arr.length -1] < arr[arr.length -2]){
        return arr.length - 1;
    }
    // 定义左右
    int left = 0;
    int right = arr.length - 1;
    int mid = 0;
    while(left < right){
        mid = left + ((right - left) >> 1);
        // mid 比左大 左侧找
        if(arr[mid] > arr[mid - 1]){
            right = mid - 1;
        // mid比右侧大 右侧找
        }else if (arr[mid] > arr[mid + 1]){
            left = mid + 1;
        }else{
            return mid;
        }
    }
    // 如果只有一个数 需要返回left
    return left;
}
```

## C3 异或

```java
// 题目四
public static void printOddTimeNum(int[] arr){
    int eor = 0;
    for(int i = 0; i < arr.length; i++){
        eor ^= arr[i];
    }
    // 提取rightone
    int rightOne = eor&(-eor);
    int onlyOne = 0;
    for(int j = 0; j < arr.length; j++){
        if((arr[i] & rightOne) != 0){
            onlyOne ^= arr[i];
        }
    }
}


// 题目五
// 一个数出现k次，其他出现m次 k< m

public static int OnlyKTime(int[] arr, int k, int m){
    int[] t = new int[32];
    for(int num : arr){
        for(int i = 0; i < 32; i++){
            // 二进制位为1时需++
            if(((num >> i) & 1) != 0){
                t[i]++;
            }
        }
    }
    int ans = 0；
    for(int i = 0; i < 32; i++){
        if(t[i] % m != 0){ // 表示在i位上有1
            ans |= (1 << i); // 把1或进去
        }
    }
    return ans;
}
// 对数器
```

## C4

```java
// 单链表结构
public class Node{
    public int value;
    public Node next;
    public Node(int data){
        value = data;
    }
}

// 双链表
public class DoubleNode{
    public int value;
    public DoubleNode last;
    public DoubleNode next;
    public DoubleNode(int data){
        value = data;
    }
}
```

- 单链表反转

```java
public static Node reverseLinkedList(Node head){
    Node next = null;
    Node pre = null;
    while(head != null){
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
```

- 删除指定节点

```java
public static Node removeValue(Node head, int num){
    // 第一个不需要删除的位置  作为头节点
    while(head != null){
        if(head.value != num){
            break;
        }
        head = head.next;
    }
    // head为null  或者head 不为null
    Node pre = head;
    Node cur = head;
    // 是value则跳过，不是则pre指向该节点
    while(cur != null){
        if(cur.value == num){
            pre.next = cur.next;
        }else{
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}
```








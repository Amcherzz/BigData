### 25 窗口内最大值和最小值更新结构



- 双端队列  滑动窗口  每个数据进一次出一次

滑动窗口  r++  右侧进入； l++某个数从左侧出窗口；左窗口不能超过r的右边



更新窗口最大值结构、双端队列，可以从头部进出，也可以从尾部进出

严格由大到小，相等也要弹出

作用：窗口缩小，l++ ,窗口中的最左边依然表明了最值

![image-20220612110347869](C:\Users\李陵晨\AppData\Roaming\Typora\typora-user-images\image-20220612110347869.png)

```java
public static int[] getMaxWindow(int[] arr, int w){
    if(arr == null || w < 1 || arr.length < w){
        return null;
    }
    // 双端队列 放入下标  最大值更新结构
    LinkedList<Integer> qmax = new LinkedList<Integer>();
    int[] res = new int[arr.length - w + 1];
    int index = 0;
    
    for(int R=0; R < arr.length; R++){
        while(!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[R]){
            qmax.pollLast();
        }
        qmax.addLast(R);
        // 过期窗口弹出 左边
        if(qmax.peekFirst() == R - W){
            qmax.pollFirst();
        }
        // 初始化窗口时期 不用收集
        if(R >= w - 1){
            res[index++] = arr[qmax.peekFirst()];
        }
    }
    return res;
}
```

![image-20220612111538719](C:\Users\李陵晨\AppData\Roaming\Typora\typora-user-images\image-20220612111538719.png)

```java
 public static int num(int[] arr, int sum){
     if (arr == null || arr.length == 0 || sum < 0){
         return 0;
     }
     int N = arr.length;
     int count = 0;
     LinkedList<Integer> maxWindow = new LinkedList<>();
     LinkedList<Integer> minWindow = new LinkedList<>();
     int R = 0;
     for (int L = 0; L < N; L++){
         while(R < N){
             // 初次不达标停
             while(!maxWindow.isEmpty() && arr[maxWindow.peekLast()] <= arr[R]){
                 maxWindow.pollLast();
             }
             maxWindow.addLast(R);
             while(!minWindow.isEmpty() && arr[minWindow.peekLast()] >= arr[R]){
                 minWindow.pollLast();
             }
             minWindow.addLast(R);
             if(arr[maxWindow.peekFirst()] - arr[minWindow.peekFirst()] > sum){
             	break;
             }else{
                 R++;
             }
         }
         count += R - L;
         if (maxWindow.peekFirst() == L){
             maxWindow.pollFirst();
         }
         if (minWindow.peekFirst() == L){
             minWindow.pollFirst();
         }
     }
     return count;
 }
```

加油站

![image-20220612113600121](C:\Users\李陵晨\AppData\Roaming\Typora\typora-user-images\image-20220612113600121.png)

  

![image-20220612113807738](C:\Users\李陵晨\AppData\Roaming\Typora\typora-user-images\image-20220612113807738.png)

计算原始累加和  数组长度扩大原来两倍，求解窗口中的最小值不能小于零

![image-20220612114254618](C:\Users\李陵晨\AppData\Roaming\Typora\typora-user-images\image-20220612114254618.png)

### 26 单调栈

数组中相邻位置的最值

```Java
public static int[][] getNearLessRepeat(int[] arr){
    int[][] res = new int[arr.length][2];
    // 只存位置 
    Stack<Integer> stack = new Stack<>();
    for(int i = 0; i < arr.length; i++){
        while(!stack.isEmpty() && arr[stack.peek()] > arr[i]){
            int popIndex = stack.pop();
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
            res[popIndex][0] = leftLessIndex;
            res[popIndex][1] = i;
        }
        stack.push(i);
    }
    while(!stack.isEmpty()){
        int popIndex = stack.pop();
        int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
        res[popIndex][0] = leftLessIndex;
        res[popIndex][1] = -1;
    }
    return res;
}
```

```java
// 支持重复的
public static int[][] getNearLessRepeat(int[] arr){
    int[][] res = new int[arr.length][2];
    // 只存位置 
    Stack<List<Integer>> stack = new Stack<>();
    for(int i = 0; i < arr.length; i++){
        while(!stack.isEmpty() && arr[stack.peek().get(0)] > arr[i]){
            List<Integer> popIs = stack.pop();
            // 取链表中最后一个数
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
            for (Integer popi : popIs){
                res[popi][0] = leftLessIndex;
                res[popi][1] = i;
            }
        }
        // 相当直接加到链表中，不相等创建一个链表
        if(!stack.isEmpty() && arr[stack.peek().get(0)] == arr[i]){
            stack.peek().add(Integer.valueOf(i));
        }else{
            ArrayList<Integer> list = new ArrayList<>();
            stack.push(list);
        }
    }
    while(!stack.isEmpty()){
        int popIndex = stack.pop();
        int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
        res[popIndex][0] = leftLessIndex;
        res[popIndex][1] = -1;
    }
    return res;
}
```

![image-20220612122124078](C:\Users\李陵晨\AppData\Roaming\Typora\typora-user-images\image-20220612122124078.png)

从数组中i开始的最为最小值的子数组 

### 27 单调栈

子数组最小和

### 28 KMP算法

字符串匹配，匹配连续子串，前缀和后缀的最长匹配长度



next 数组  初始-1  0  先求s2的数组  让匹配过程加速

因为next数组中对称相等  匹配不一致中向后推相等长度  匹配加速

前面相等的不重复验证

```java
public class CodeKMP{
    public static int getIndexOf(String s1, String s2){
        if(s1 == null || s2 == null || s2.length() < 1 || s1.length() < s2.length()){
            return -1;
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        int x = 0;
        int y = 0;
        int[] next = getNextArray(str2);
        while(x < str1.length && y < str2.length){
            if(str1[x] == str2[y]){
                x++;
                y++;
            }else if(next[y] == -1){ // y==0
                x++;
            }else{
                y = next[y];
            }
        }
        return y == str2.length ? x - y : -1;
    }
}
```


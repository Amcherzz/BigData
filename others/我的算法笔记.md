## BFS



创建queque

创建visited

遍历queque

操作函数何时返回何时添加



#### [127. Word Ladder](https://leetcode.cn/problems/word-ladder/)

A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:

Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists

转换每个单词 枚举是否在字典中

- BFS和双向BFS 更加缩短时间

```python
# 采用BFS的思想遍历

import collections

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        # write your code here
        word_set = set(wordList)
        if len(word_set) == 0 or endWord not in word_set:
            return 0

        # 队列 visited 防止重复访问
        queue = collections.deque([beginWord])
        visited = set(beginWord)

        # 初始化距离
        distance = 0
        while queue:
            # 层级嵌套， 距离叠加
            distance += 1
            # java注意len变化，python可行，因为后面会有append改变队列大学
            for _ in range(len(queue)):
                word = queue.popleft()
                # 如果等于最后一个就可以返回了
                if word == endWord:
                    # 第一次找到了返回函数，保证了最小值
                    return distance
                # 变化单个字符，返回属于dict中，并且未被访问的加入queue中
                for next_word in self.get_next_word(word, word_set):
                    if next_word in visited:
                        continue
                    visited.add(next_word)
                    queue.append(next_word)
        return 0


    def get_next_word(self, word, dict):
        next_words = []
        for i in range(len(word)):
            # 切片思想，高端
            left, right = word[:i], word[i+1:]
            for char in 'abcdefghijklmnopqrstuvwxyz':
                if word[i] == char:
                    continue
                new_word = left + char + right
                # 判断是否在字典中
                if new_word in dict:
                    next_words.append(new_word)
        return next_words
```

#### [200. Number of Islands](https://leetcode.cn/problems/number-of-islands/)

Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.



BFS题目，网格类型   并查集 广度和深度优先

```python
# BFS
import collections

# 改变方向
DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        islands = 0
        visited = set()

        # 遍历整个网格
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                # 如果为1 则BFS查询附近的
                if grid[i][j] == '1' and (i, j) not in visited:
                    self.bfs(grid, i, j, visited)
                    # 因为为1 所以要加1
                    islands += 1
        return islands

    def bfs(self, grid, x, y, visited):
        queue = collections.deque([(x, y)])
        # 添加外层
        visited.add((x, y))
        while queue:
            x, y = queue.popleft()
            for delta_x, delta_y in DIR:
                next_x = x + delta_x
                next_y = y + delta_y
                if not self.is_valid(grid, next_x, next_y, visited):
                    continue
                queue.append((next_x, next_y))
                # 添加附近的
                visited.add((next_x, next_y))

    def is_valid(self, grid, x, y, visited):
        # 是否越界 是否为零 无效则无需添加到队列中遍历
        max_x, max_y = len(grid), len(grid[0])
        if not (0 <= x < max_x and 0 <= y < max_y):
            return False
        if (x, y) in visited or grid[x][y] == '0':
            return False
        return True
```



```python
# DFS
class Solution:

    def dfs(self, grid, x, y):
        # 四个方向
        for next_x, next_y in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:
            # 判断是否越界 和 是否为1 ，赋值0，再继续调用
            if 0 <= next_x < len(grid) and 0 <= next_y < len(grid[0]) and grid[next_x][next_y] == '1':
                grid[next_x][next_y] = 0
                self.dfs(grid, next_x, next_y)
        return

    def numIslands(self, grid) -> int:
        if not grid or len(grid[0]) == 0:
            return 0
        islands = 0

        for i in range(len(grid)):
            for j in range(len(grid[0])):
                # 最外层 找到为1的，深度搜索附近，将1的复制为0 再返回
                if grid[i][j] == "1":
                    islands += 1
                    self.dfs(grid, i, j)

        return islands
```

